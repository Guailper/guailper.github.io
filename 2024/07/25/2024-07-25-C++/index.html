<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"guailper.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="C++重载运算符重载1234函数类型 operator运算符(形参列表)&#123;    重载语句;&#125;  operator为关键字，专门用于定义运算符重载的函数。可以将 operator运算符 看成函数名称。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++操作符重载&amp;引用">
<meta property="og:url" content="https://guailper.github.io/2024/07/25/2024-07-25-C++/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="C++重载运算符重载1234函数类型 operator运算符(形参列表)&#123;    重载语句;&#125;  operator为关键字，专门用于定义运算符重载的函数。可以将 operator运算符 看成函数名称。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-07-25T02:50:52.000Z">
<meta property="article:modified_time" content="2025-12-18T15:59:07.694Z">
<meta property="article:author" content="Guailper">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://guailper.github.io/2024/07/25/2024-07-25-C++/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++操作符重载&引用 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">17</span></a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-fw fa-calendar"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
        <li class="menu-item menu-item-search">

    <a href="/search/" rel="section"><i class="fa fa-fw fa-search"></i>搜索</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://guailper.github.io/2024/07/25/2024-07-25-C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Guailper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++操作符重载&引用
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-25 10:50:52" itemprop="dateCreated datePublished" datetime="2024-07-25T10:50:52+08:00">2024-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-12-18 23:59:07" itemprop="dateModified" datetime="2025-12-18T23:59:07+08:00">2025-12-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数类型 <span class="keyword">operator</span>运算符(形参列表)</span><br><span class="line">&#123;</span><br><span class="line">    重载语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>operator</code>为关键字，专门用于定义运算符重载的函数。可以将 <strong>operator运算符</strong> 看成函数名称。</p>
<span id="more"></span>

<h4 id="运算符重载规则："><a href="#运算符重载规则：" class="headerlink" title="运算符重载规则："></a>运算符重载规则：</h4><p>1.并不是所有的运算符都能被重载，如长度运算符<code>sizeof</code>、条件运算符<code>: ?</code>（三元运算符）、成员选择符<code>.</code>和域解析运算符<code>::</code>不能被重载。</p>
<p>2.重载不能改变运算符的优先级和结合性。</p>
<p>3.重载不改变运算符的用法（即不改变原先的使用规则）。</p>
<p>4.运算符重载函数<strong>不能有默认参数</strong>，因为这会改变运算符操作数个数。</p>
<p>5.运算符重载函数既可以作为<strong>类的成员函数</strong>，也可以作为<strong>全局函数</strong>。</p>
<p>将运算符重载函数作为类的成员函数时，二元运算符的参数只有一个，一元运算符不需要参数。之所以少一个参数，是因为这个参数是隐含的。当类的对象调用重载后的运算符时，此对象就隐形作为一个参数了。</p>
<p>将运算符重载函数作为全局函数时，二元操作符就需要两个参数，一元操作符需要一个参数，<strong>而且其中必须有一个参数是对象</strong>，好让编译器区分这是程序员自定义的运算符，防止程序员修改用于内置类型的运算符的性质。</p>
<p>6.箭头运算符<code>-&gt;</code>、下标运算符<code>[ ]</code>、函数调用运算符<code>( )</code>、赋值运算符<code>=</code>只能以成员函数的形式重载。</p>
<h4 id="流操作符重载"><a href="#流操作符重载" class="headerlink" title="流操作符重载"></a>流操作符重载</h4><p>输入流操作符<code>&gt;&gt;</code>和输出流操作符<code>&lt;&lt;</code>。</p>
<p><code>cout</code>是<code>ostream类</code>对象，<code>cin</code>是<code>iostream类</code>对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入流操作符&gt;&gt;重载</span></span><br><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;in, 类型 &amp;A)</span><br><span class="line">&#123;</span><br><span class="line">    in &gt;&gt; A.成员<span class="number">1</span> &gt;&gt; A.成员<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回 istream 类对象的引用，是为了能够连续读取复数，让代码书写更加漂亮</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出流操作符&lt;&lt;重载</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, 类型 &amp;A)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; A.成员<span class="number">1</span> &lt;&lt; A.成员<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="下标运算符-重载"><a href="#下标运算符-重载" class="headerlink" title="下标运算符[]重载"></a>下标运算符<code>[]</code>重载</h4><p>只能以成员函数的形式进行重载，声明格式一般为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式:不仅可以访问元素，还可以修改元素。</span></span><br><span class="line">返回值类型 &amp; <span class="keyword">operator</span>[](形参);</span><br><span class="line"><span class="comment">//第二种方式:只能访问而不能修改元素</span></span><br><span class="line"><span class="type">const</span> 返回值类型 &amp; <span class="keyword">operator</span>[](形参) <span class="type">const</span>;</span><br></pre></td></tr></table></figure>

<p>可以通过重载<code>[]</code>来实现变长数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">int</span> length = <span class="number">0</span>);</span><br><span class="line">    ~<span class="built_in">Array</span>();</span><br><span class="line">    <span class="type">int</span> &amp; <span class="keyword">operator</span>[](<span class="type">int</span> i);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp; <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_length;  <span class="comment">//数组长度</span></span><br><span class="line">    <span class="type">int</span> *m_p;  <span class="comment">//指向数组内存的指针</span></span><br><span class="line">&#125;;</span><br><span class="line">Array::~<span class="built_in">Array</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>&amp; Array::<span class="keyword">operator</span>[](<span class="type">int</span> i)&#123;</span><br><span class="line">    <span class="keyword">return</span> m_p[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp; Array::<span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_p[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><h4 id="（1）流操作符重载"><a href="#（1）流操作符重载" class="headerlink" title="（1）流操作符重载"></a>（1）流操作符重载</h4><p>必须作为友元函数（关键字：<strong>friend</strong>）或普通全局函数来重载。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std:ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os,<span class="type">const</span> className&amp; object)&#123;</span><br><span class="line">    os &lt;&lt; object的内容;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std:istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is,className&amp; object)&#123;</span><br><span class="line">    os &gt;&gt; object的内容;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（2）一元运算符重载（-、–、-、-）"><a href="#（2）一元运算符重载（-、–、-、-）" class="headerlink" title="（2）一元运算符重载（++、–、-、!）"></a>（2）一元运算符重载（++、–、-、!）</h4><p>前缀形式重载调用 <strong>operator ++ ()</strong> ，后缀形式重载调用 <strong>operator ++ (int)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载前缀递增运算符（ ++ ）</span></span><br><span class="line">      Time <span class="keyword">operator</span>++ ()  </span><br><span class="line">      &#123;</span><br><span class="line">         ++minutes;          <span class="comment">// 对象加 1</span></span><br><span class="line">         <span class="keyword">if</span>(minutes &gt;= <span class="number">60</span>)  </span><br><span class="line">         &#123;</span><br><span class="line">            ++hours;</span><br><span class="line">            minutes -= <span class="number">60</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">Time</span>(hours, minutes);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 重载后缀递增运算符（ ++ ）</span></span><br><span class="line">      Time <span class="keyword">operator</span>++( <span class="type">int</span> )         </span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">// 保存原始值</span></span><br><span class="line">         <span class="function">Time <span class="title">T</span><span class="params">(hours, minutes)</span></span>;</span><br><span class="line">         <span class="comment">// 对象加 1</span></span><br><span class="line">         ++minutes;                    </span><br><span class="line">         <span class="keyword">if</span>(minutes &gt;= <span class="number">60</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            ++hours;</span><br><span class="line">            minutes -= <span class="number">60</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 返回旧的原始值</span></span><br><span class="line">         <span class="keyword">return</span> T; </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="（3）二元运算符重载（-、-、-、-）"><a href="#（3）二元运算符重载（-、-、-、-）" class="headerlink" title="（3）二元运算符重载（+、-、*、&#x2F;）"></a>（3）二元运算符重载（+、-、*、&#x2F;）</h4><p>类成员函数或全局函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类成员函数重载 + 运算符，用于把两个 Box 对象相加</span></span><br><span class="line">   Box <span class="keyword">operator</span>+(<span class="type">const</span> Box&amp; b)</span><br><span class="line">   &#123;</span><br><span class="line">      Box box;</span><br><span class="line">      box.length = <span class="keyword">this</span>-&gt;length + b.length;</span><br><span class="line">      box.breadth = <span class="keyword">this</span>-&gt;breadth + b.breadth;</span><br><span class="line">      box.height = <span class="keyword">this</span>-&gt;height + b.height;</span><br><span class="line">      <span class="keyword">return</span> box;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//其他运算符类似</span></span><br><span class="line"><span class="comment">//全局函数重载</span></span><br><span class="line">Box <span class="keyword">operator</span>+(<span class="type">const</span> Box&amp; a, <span class="type">const</span> Box&amp; b)</span><br><span class="line">   &#123;</span><br><span class="line">      Box box;</span><br><span class="line">      box.length = a.length + b.length;</span><br><span class="line">      box.breadth = a.breadth + b.breadth;</span><br><span class="line">      box.height = a.height + b.height;</span><br><span class="line">      <span class="keyword">return</span> box;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="（4）赋值运算符"><a href="#（4）赋值运算符" class="headerlink" title="（4）赋值运算符"></a>（4）赋值运算符</h4><ul>
<li>参数类型：引用传参，用const修饰，即const 类&amp;<br>引用传参可以提高传参效率。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Distance &amp;D )</span><br><span class="line">      &#123; </span><br><span class="line">         feet = D.feet;</span><br><span class="line">         inches = D.inches;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>返回值类型：引用返回，即 类&amp;<br>引用返回可以提高返回的效率，有返回值目的是为了支持连续赋值功能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Data <span class="keyword">operator</span>=(<span class="type">const</span> Data&amp; d)<span class="comment">//可以提高效率</span></span><br><span class="line">	&#123;</span><br><span class="line">			_year = d._year;</span><br><span class="line">			_month = d._month;</span><br><span class="line">			_day = d._day;</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>要检查是否给自己赋值</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Data <span class="keyword">operator</span>=(<span class="type">const</span> Data&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;d)<span class="comment">//如果两个对象的地址不相同那么就可以进行赋值</span></span><br><span class="line">	&#123;</span><br><span class="line">		_year = d._year;</span><br><span class="line">		_month = d._month;</span><br><span class="line">		_day = d._day;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>返回*this：要符合连续赋值的含义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Data&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Data&amp; d)<span class="comment">//用引用返回，可以提高效率,减少拷贝</span></span><br><span class="line">	&#123;</span><br><span class="line">			_year = d._year;</span><br><span class="line">			_month = d._month;</span><br><span class="line">			_day = d._day;</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（5）函数调用运算符-重载"><a href="#（5）函数调用运算符-重载" class="headerlink" title="（5）函数调用运算符()重载"></a>（5）函数调用运算符()重载</h4><p>函数调用运算符 () 可以被重载用于类的对象。当重载 () 时，您不是创造了一种新的调用函数的方式，相反地，这是创建一个可以传递任意数目参数的运算符函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载函数调用运算符</span></span><br><span class="line">      <span class="function">Distance <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         Distance D;</span><br><span class="line">         <span class="comment">// 进行随机计算</span></span><br><span class="line">         D.feet = a + c + <span class="number">10</span>;</span><br><span class="line">         D.inches = b + c + <span class="number">100</span> ;</span><br><span class="line">         <span class="keyword">return</span> D;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="（6）下标运算符-重载"><a href="#（6）下标运算符-重载" class="headerlink" title="（6）下标运算符[]重载"></a>（6）下标运算符[]重载</h4><p>下标操作符 [] 通常用于访问数组元素。重载该运算符用于增强操作 C++ 数组的功能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>( i &gt;= SIZE )</span><br><span class="line">          &#123;</span><br><span class="line">              cout &lt;&lt; <span class="string">&quot;索引超过最大值&quot;</span> &lt;&lt;endl; </span><br><span class="line">              <span class="comment">// 返回第一个元素</span></span><br><span class="line">              <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> arr[i];</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="（7）类成员访问运算符-重载"><a href="#（7）类成员访问运算符-重载" class="headerlink" title="（7）类成员访问运算符-&gt;重载"></a>（7）类成员访问运算符-&gt;重载</h4><p>运算符 -&gt; 通常与指针引用运算符 * 结合使用，用于实现”智能指针”的功能。</p>
<p>语句 p-&gt;m 被解释为 (p.operator-&gt;())-&gt;m</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Obj* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> </span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span>(!oc.a[index])</span><br><span class="line">     &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Zero value&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> (Obj*)<span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> oc.a[index];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用必须在声明时初始化，初始化后无法改变指向。</p>
<p><strong>左值、右值的区别：</strong></p>
<p>左值：可以取地址的对象</p>
<p>右值：不可以取地址的对象（如常量、表达式、函数返回值）</p>
<h3 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h3><p>就是对左值进行引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.左值引用只能引用左值</span></span><br><span class="line"><span class="type">int</span> t = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>&amp; rt1 = t;</span><br><span class="line"><span class="comment">//int&amp; rt2 = 8;  // 编译报错，因为8是右值，不能直接引用右值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.但是const左值引用既可以引用左值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rt3 = t;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rt4 = <span class="number">8</span>;  <span class="comment">// 也可以引用右值</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span>&amp; r1 = x + y;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span>&amp; r2 = <span class="built_in">fmin</span>(x, y);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>就是对右值进行引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.右值引用只能引用右值</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; rr1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span>&amp;&amp; rr2 = x + y;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span>&amp;&amp; rr3 = x + y;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int&amp;&amp; rrt = t;  // 编译报错，不能直接引用左值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.但是右值引用可以引用被move的左值</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; rrt = std::<span class="built_in">move</span>(t);</span><br><span class="line"><span class="type">int</span>*&amp;&amp; rr4 = std::<span class="built_in">move</span>(p);</span><br><span class="line"><span class="type">int</span>&amp;&amp; rr5 = std::<span class="built_in">move</span>(*p);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; rr6 = std::<span class="built_in">move</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//std::move移动语义：将一个对象中的资源移动到另一个对象（资源控制权的转移）</span></span><br></pre></td></tr></table></figure>

<h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>浅拷贝是创建一个新对象，新对象和原对象共享同一个底层资源，简单的赋值拷贝。浅拷贝在拷贝后对象共享同一份底层资源，可以提高效率，但是当对象<strong>析构</strong>时可能会出现不确定的行为，因为<strong>资源会被重复释放</strong>。</p>
<p>深拷贝则是创建一个新对象，，在堆中重新分配空间，新对象拥有原对象的全部资源，二者之间互不影响。深拷贝则会为每个对象创建独立的底层资源，避免了这个问题，但是会<strong>占用更多的内存</strong>。</p>
<p>当对象中有<strong>指针指向动态分配的内存</strong>时，为了安全地复制对象，需要显式地实现深拷贝，通常通过重载类的拷贝构造函数和赋值操作符来完成</p>
<h2 id="类与结构体"><a href="#类与结构体" class="headerlink" title="类与结构体"></a>类与结构体</h2><p>C语言中，结构体只是用来封装不同数据类型的数据，没有构造函数和成员函数。</p>
<p>C++中，结构体除了默认权限和继承默认权限不一样外，其他功能与类一样。（结构体默认public，类默认private）</p>
<p>在类定义中的<strong>定义</strong>的函数都是<strong>内联函数</strong>，即使没有使用 <strong>inline</strong> 说明符。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>派生类可以访问基类中所有的<strong>非私有</strong>成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p>
<p>一个派生类继承了所有的基类方法，但下列情况除外：</p>
<ul>
<li>基类的构造函数、析构函数和拷贝构造函数。</li>
<li>基类的重载运算符。</li>
<li>基类的友元函数。</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p>
<p>编译时多态、静态多态（静态链接或早绑定）：函数调用在程序执行前就准备好了。有时候这也被称为<strong>早绑定</strong>，因为 area() 函数在程序编译期间就已经设置好了，如<strong>函数重载</strong>和<strong>运算符重载</strong></p>
<p>运行时多态、动态多态（动态链接或后期绑定）：根据所调用的对象类型来选择调用的函数，如派生类中的<strong>虚函数重写</strong></p>
<h5 id="虚函数与纯虚函数"><a href="#虚函数与纯虚函数" class="headerlink" title="虚函数与纯虚函数"></a>虚函数与纯虚函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> returnType <span class="title">functionName</span><span class="params">()</span></span>&#123;</span><br><span class="line">	···</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//纯虚函数,派生类必须重写纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> returnType <span class="title">functionName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>当类中有虚函数时，会为该类生成一个虚函数指针表（虚函数表），同时为该类添加一个虚函数表指针成员（用于访问虚函数表），表中包含一个或多个函数指针，指向该类的虚函数地址</p>
<h3 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h3><p>只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。</p>
<p><strong>优势：</strong></p>
<ul>
<li>类的内部受到保护，不会因无意的用户级错误导致对象状态受损。</li>
<li>类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。</li>
</ul>
<h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><p>把数据和操作数据的函数捆绑在一起，通过将数据和操作数据的函数封装在一个类中来实现。</p>
<p><strong>访问修饰符</strong></p>
<ul>
<li><strong>private</strong>: 私有成员只能在类的内部访问，不能被类的外部代码直接访问。</li>
<li><strong>public</strong>: 公有成员可以被类的外部代码直接访问。</li>
<li><strong>protected</strong>: 受保护成员可以被类和其派生类访问。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li><strong>数据隐藏</strong>: 通过将数据成员声明为私有，防止外部代码直接访问这些数据。</li>
<li><strong>提高代码可维护性</strong>: 提供公共方法来访问和修改数据，这使得可以在不影响外部代码的情况下修改类的内部实现。</li>
<li><strong>增强安全性</strong>: 防止不合法的数据输入和不当的修改操作。</li>
<li><strong>实现抽象</strong>: 提供了一种机制，使得用户不需要了解类的内部实现细节，只需要了解如何使用类的公共接口即可。</li>
</ul>
<h3 id="接口（抽象类ABC）"><a href="#接口（抽象类ABC）" class="headerlink" title="接口（抽象类ABC）"></a>接口（抽象类ABC）</h3><p>类中<strong>至少</strong>有一个函数被声明为<strong>纯虚函数</strong>，则这个类就是抽象类。纯虚函数是通过在声明中使用 “&#x3D; 0” 来指定的。C++的接口是通过抽象类来实现的，抽象类不能被用于实例化对象，它只能作为<strong>接口</strong>使用。</p>
<p>如果一个 ABC 的子类需要被实例化，则必须实现每个纯虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。可用于实例化对象的类被称为<strong>具体类</strong>。</p>
<h3 id="构造函数类"><a href="#构造函数类" class="headerlink" title="构造函数类"></a>构造函数类</h3><p>按参数区分：有参、无参（默认构造函数）</p>
<p>按照类型区分：普通、拷贝(或复制构造)</p>
<p>拷贝构造调用情景：</p>
<p>1.对象以值的形式作为函数参数</p>
<p>2.对象以值的形式作为函数返回值</p>
<p>3.将一个对象用于给另一对象进行初始化时</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">//拷贝构造，形参必须为引用，一般会加const</span></span><br><span class="line">    <span class="comment">//一般拷贝构造函数为浅拷贝，当成员变量中存在指针变量时需定义一个深拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p)&#123;</span><br><span class="line">        <span class="meta">#statement</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/16/2022-8-16-Linux%E4%B8%8Bgdb%E8%B0%83%E8%AF%95/" rel="prev" title="Linux下gdb调试">
      <i class="fa fa-chevron-left"></i> Linux下gdb调试
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/03/05/C++%E9%9D%A2%E7%BB%8F/" rel="next" title="C++面经">
      C++面经 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C"><span class="nav-number">1.</span> <span class="nav-text">C++</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD"><span class="nav-number">1.1.</span> <span class="nav-text">重载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">1.1.1.</span> <span class="nav-text">运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E8%A7%84%E5%88%99%EF%BC%9A"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">运算符重载规则：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">流操作符重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%87%8D%E8%BD%BD"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">下标运算符[]重载</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">1.1.2.</span> <span class="nav-text">操作符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%B5%81%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">（1）流操作符重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%EF%BC%88-%E3%80%81%E2%80%93%E3%80%81-%E3%80%81-%EF%BC%89"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">（2）一元运算符重载（++、–、-、!）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%EF%BC%88-%E3%80%81-%E3%80%81-%E3%80%81-%EF%BC%89"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">（3）二元运算符重载（+、-、*、&#x2F;）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">（4）赋值运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%87%8D%E8%BD%BD"><span class="nav-number">1.1.2.5.</span> <span class="nav-text">（5）函数调用运算符()重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%886%EF%BC%89%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%87%8D%E8%BD%BD"><span class="nav-number">1.1.2.6.</span> <span class="nav-text">（6）下标运算符[]重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%887%EF%BC%89%E7%B1%BB%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%87%8D%E8%BD%BD"><span class="nav-number">1.1.2.7.</span> <span class="nav-text">（7）类成员访问运算符-&gt;重载</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">1.2.</span> <span class="nav-text">引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-number">1.2.1.</span> <span class="nav-text">左值引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-number">1.2.2.</span> <span class="nav-text">右值引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.3.</span> <span class="nav-text">深拷贝与浅拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.4.</span> <span class="nav-text">类与结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">1.4.1.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">1.4.2.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.2.0.1.</span> <span class="nav-text">虚函数与纯虚函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1"><span class="nav-number">1.4.3.</span> <span class="nav-text">数据抽象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85"><span class="nav-number">1.4.4.</span> <span class="nav-text">数据封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%B1%BBABC%EF%BC%89"><span class="nav-number">1.4.5.</span> <span class="nav-text">接口（抽象类ABC）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%B1%BB"><span class="nav-number">1.4.6.</span> <span class="nav-text">构造函数类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8"><span class="nav-number">1.5.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vector"><span class="nav-number">1.5.1.</span> <span class="nav-text">vector</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Guailper</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Guailper</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
