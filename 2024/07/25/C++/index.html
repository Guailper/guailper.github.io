<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++操作符重载&amp;引用 | Guailper的博客</title><meta name="author" content="Guailper"><meta name="copyright" content="Guailper"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++重载运算符重载1234函数类型 operator运算符(形参列表)&#123;    重载语句;&#125;  operator为关键字，专门用于定义运算符重载的函数。可以将 operator运算符 看成函数名称。">
<meta property="og:type" content="website">
<meta property="og:title" content="C++操作符重载&amp;引用">
<meta property="og:url" content="https://guailper.github.io/2024/07/25/C++/index.html">
<meta property="og:site_name" content="Guailper的博客">
<meta property="og:description" content="C++重载运算符重载1234函数类型 operator运算符(形参列表)&#123;    重载语句;&#125;  operator为关键字，专门用于定义运算符重载的函数。可以将 operator运算符 看成函数名称。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://guailper.github.io/img/cover.png">
<meta property="article:published_time" content="2024-07-24T16:00:00.000Z">
<meta property="article:modified_time" content="2025-12-18T15:59:07.694Z">
<meta property="article:author" content="Guailper">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://guailper.github.io/img/cover.png"><script type="application/ld+json"></script><link rel="shortcut icon" href="/img/guailper.png"><link rel="canonical" href="https://guailper.github.io/2024/07/25/C++/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++操作符重载&引用',
  isHighlightShrink: false,
  isToc: false,
  pageType: 'article'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="not-home-page fixed" id="page-header" style="background-image: url(/img/top_img.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Guailper的博客</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="page-site-info"><h1 id="site-title">C++操作符重载&amp;引用</h1></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数类型 <span class="keyword">operator</span>运算符(形参列表)</span><br><span class="line">&#123;</span><br><span class="line">    重载语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>operator</code>为关键字，专门用于定义运算符重载的函数。可以将 <strong>operator运算符</strong> 看成函数名称。</p>
<span id="more"></span>

<h4 id="运算符重载规则："><a href="#运算符重载规则：" class="headerlink" title="运算符重载规则："></a>运算符重载规则：</h4><p>1.并不是所有的运算符都能被重载，如长度运算符<code>sizeof</code>、条件运算符<code>: ?</code>（三元运算符）、成员选择符<code>.</code>和域解析运算符<code>::</code>不能被重载。</p>
<p>2.重载不能改变运算符的优先级和结合性。</p>
<p>3.重载不改变运算符的用法（即不改变原先的使用规则）。</p>
<p>4.运算符重载函数<strong>不能有默认参数</strong>，因为这会改变运算符操作数个数。</p>
<p>5.运算符重载函数既可以作为<strong>类的成员函数</strong>，也可以作为<strong>全局函数</strong>。</p>
<p>将运算符重载函数作为类的成员函数时，二元运算符的参数只有一个，一元运算符不需要参数。之所以少一个参数，是因为这个参数是隐含的。当类的对象调用重载后的运算符时，此对象就隐形作为一个参数了。</p>
<p>将运算符重载函数作为全局函数时，二元操作符就需要两个参数，一元操作符需要一个参数，<strong>而且其中必须有一个参数是对象</strong>，好让编译器区分这是程序员自定义的运算符，防止程序员修改用于内置类型的运算符的性质。</p>
<p>6.箭头运算符<code>-&gt;</code>、下标运算符<code>[ ]</code>、函数调用运算符<code>( )</code>、赋值运算符<code>=</code>只能以成员函数的形式重载。</p>
<h4 id="流操作符重载"><a href="#流操作符重载" class="headerlink" title="流操作符重载"></a>流操作符重载</h4><p>输入流操作符<code>&gt;&gt;</code>和输出流操作符<code>&lt;&lt;</code>。</p>
<p><code>cout</code>是<code>ostream类</code>对象，<code>cin</code>是<code>iostream类</code>对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入流操作符&gt;&gt;重载</span></span><br><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;in, 类型 &amp;A)</span><br><span class="line">&#123;</span><br><span class="line">    in &gt;&gt; A.成员<span class="number">1</span> &gt;&gt; A.成员<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回 istream 类对象的引用，是为了能够连续读取复数，让代码书写更加漂亮</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出流操作符&lt;&lt;重载</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, 类型 &amp;A)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; A.成员<span class="number">1</span> &lt;&lt; A.成员<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="下标运算符-重载"><a href="#下标运算符-重载" class="headerlink" title="下标运算符[]重载"></a>下标运算符<code>[]</code>重载</h4><p>只能以成员函数的形式进行重载，声明格式一般为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式:不仅可以访问元素，还可以修改元素。</span></span><br><span class="line">返回值类型 &amp; <span class="keyword">operator</span>[](形参);</span><br><span class="line"><span class="comment">//第二种方式:只能访问而不能修改元素</span></span><br><span class="line"><span class="type">const</span> 返回值类型 &amp; <span class="keyword">operator</span>[](形参) <span class="type">const</span>;</span><br></pre></td></tr></table></figure>

<p>可以通过重载<code>[]</code>来实现变长数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">int</span> length = <span class="number">0</span>);</span><br><span class="line">    ~<span class="built_in">Array</span>();</span><br><span class="line">    <span class="type">int</span> &amp; <span class="keyword">operator</span>[](<span class="type">int</span> i);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp; <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_length;  <span class="comment">//数组长度</span></span><br><span class="line">    <span class="type">int</span> *m_p;  <span class="comment">//指向数组内存的指针</span></span><br><span class="line">&#125;;</span><br><span class="line">Array::~<span class="built_in">Array</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>&amp; Array::<span class="keyword">operator</span>[](<span class="type">int</span> i)&#123;</span><br><span class="line">    <span class="keyword">return</span> m_p[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp; Array::<span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_p[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><h4 id="（1）流操作符重载"><a href="#（1）流操作符重载" class="headerlink" title="（1）流操作符重载"></a>（1）流操作符重载</h4><p>必须作为友元函数（关键字：<strong>friend</strong>）或普通全局函数来重载。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std:ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os,<span class="type">const</span> className&amp; object)&#123;</span><br><span class="line">    os &lt;&lt; object的内容;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std:istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is,className&amp; object)&#123;</span><br><span class="line">    os &gt;&gt; object的内容;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（2）一元运算符重载（-、–、-、-）"><a href="#（2）一元运算符重载（-、–、-、-）" class="headerlink" title="（2）一元运算符重载（++、–、-、!）"></a>（2）一元运算符重载（++、–、-、!）</h4><p>前缀形式重载调用 <strong>operator ++ ()</strong> ，后缀形式重载调用 <strong>operator ++ (int)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载前缀递增运算符（ ++ ）</span></span><br><span class="line">      Time <span class="keyword">operator</span>++ ()  </span><br><span class="line">      &#123;</span><br><span class="line">         ++minutes;          <span class="comment">// 对象加 1</span></span><br><span class="line">         <span class="keyword">if</span>(minutes &gt;= <span class="number">60</span>)  </span><br><span class="line">         &#123;</span><br><span class="line">            ++hours;</span><br><span class="line">            minutes -= <span class="number">60</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">Time</span>(hours, minutes);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 重载后缀递增运算符（ ++ ）</span></span><br><span class="line">      Time <span class="keyword">operator</span>++( <span class="type">int</span> )         </span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">// 保存原始值</span></span><br><span class="line">         <span class="function">Time <span class="title">T</span><span class="params">(hours, minutes)</span></span>;</span><br><span class="line">         <span class="comment">// 对象加 1</span></span><br><span class="line">         ++minutes;                    </span><br><span class="line">         <span class="keyword">if</span>(minutes &gt;= <span class="number">60</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            ++hours;</span><br><span class="line">            minutes -= <span class="number">60</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 返回旧的原始值</span></span><br><span class="line">         <span class="keyword">return</span> T; </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="（3）二元运算符重载（-、-、-、-）"><a href="#（3）二元运算符重载（-、-、-、-）" class="headerlink" title="（3）二元运算符重载（+、-、*、&#x2F;）"></a>（3）二元运算符重载（+、-、*、&#x2F;）</h4><p>类成员函数或全局函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类成员函数重载 + 运算符，用于把两个 Box 对象相加</span></span><br><span class="line">   Box <span class="keyword">operator</span>+(<span class="type">const</span> Box&amp; b)</span><br><span class="line">   &#123;</span><br><span class="line">      Box box;</span><br><span class="line">      box.length = <span class="keyword">this</span>-&gt;length + b.length;</span><br><span class="line">      box.breadth = <span class="keyword">this</span>-&gt;breadth + b.breadth;</span><br><span class="line">      box.height = <span class="keyword">this</span>-&gt;height + b.height;</span><br><span class="line">      <span class="keyword">return</span> box;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//其他运算符类似</span></span><br><span class="line"><span class="comment">//全局函数重载</span></span><br><span class="line">Box <span class="keyword">operator</span>+(<span class="type">const</span> Box&amp; a, <span class="type">const</span> Box&amp; b)</span><br><span class="line">   &#123;</span><br><span class="line">      Box box;</span><br><span class="line">      box.length = a.length + b.length;</span><br><span class="line">      box.breadth = a.breadth + b.breadth;</span><br><span class="line">      box.height = a.height + b.height;</span><br><span class="line">      <span class="keyword">return</span> box;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="（4）赋值运算符"><a href="#（4）赋值运算符" class="headerlink" title="（4）赋值运算符"></a>（4）赋值运算符</h4><ul>
<li>参数类型：引用传参，用const修饰，即const 类&amp;<br>引用传参可以提高传参效率。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Distance &amp;D )</span><br><span class="line">      &#123; </span><br><span class="line">         feet = D.feet;</span><br><span class="line">         inches = D.inches;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>返回值类型：引用返回，即 类&amp;<br>引用返回可以提高返回的效率，有返回值目的是为了支持连续赋值功能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Data <span class="keyword">operator</span>=(<span class="type">const</span> Data&amp; d)<span class="comment">//可以提高效率</span></span><br><span class="line">	&#123;</span><br><span class="line">			_year = d._year;</span><br><span class="line">			_month = d._month;</span><br><span class="line">			_day = d._day;</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>要检查是否给自己赋值</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Data <span class="keyword">operator</span>=(<span class="type">const</span> Data&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;d)<span class="comment">//如果两个对象的地址不相同那么就可以进行赋值</span></span><br><span class="line">	&#123;</span><br><span class="line">		_year = d._year;</span><br><span class="line">		_month = d._month;</span><br><span class="line">		_day = d._day;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>返回*this：要符合连续赋值的含义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Data&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Data&amp; d)<span class="comment">//用引用返回，可以提高效率,减少拷贝</span></span><br><span class="line">	&#123;</span><br><span class="line">			_year = d._year;</span><br><span class="line">			_month = d._month;</span><br><span class="line">			_day = d._day;</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（5）函数调用运算符-重载"><a href="#（5）函数调用运算符-重载" class="headerlink" title="（5）函数调用运算符()重载"></a>（5）函数调用运算符()重载</h4><p>函数调用运算符 () 可以被重载用于类的对象。当重载 () 时，您不是创造了一种新的调用函数的方式，相反地，这是创建一个可以传递任意数目参数的运算符函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载函数调用运算符</span></span><br><span class="line">      <span class="function">Distance <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         Distance D;</span><br><span class="line">         <span class="comment">// 进行随机计算</span></span><br><span class="line">         D.feet = a + c + <span class="number">10</span>;</span><br><span class="line">         D.inches = b + c + <span class="number">100</span> ;</span><br><span class="line">         <span class="keyword">return</span> D;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="（6）下标运算符-重载"><a href="#（6）下标运算符-重载" class="headerlink" title="（6）下标运算符[]重载"></a>（6）下标运算符[]重载</h4><p>下标操作符 [] 通常用于访问数组元素。重载该运算符用于增强操作 C++ 数组的功能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>( i &gt;= SIZE )</span><br><span class="line">          &#123;</span><br><span class="line">              cout &lt;&lt; <span class="string">&quot;索引超过最大值&quot;</span> &lt;&lt;endl; </span><br><span class="line">              <span class="comment">// 返回第一个元素</span></span><br><span class="line">              <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> arr[i];</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="（7）类成员访问运算符-重载"><a href="#（7）类成员访问运算符-重载" class="headerlink" title="（7）类成员访问运算符-&gt;重载"></a>（7）类成员访问运算符-&gt;重载</h4><p>运算符 -&gt; 通常与指针引用运算符 * 结合使用，用于实现”智能指针”的功能。</p>
<p>语句 p-&gt;m 被解释为 (p.operator-&gt;())-&gt;m</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Obj* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> </span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span>(!oc.a[index])</span><br><span class="line">     &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Zero value&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> (Obj*)<span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> oc.a[index];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用必须在声明时初始化，初始化后无法改变指向。</p>
<p><strong>左值、右值的区别：</strong></p>
<p>左值：可以取地址的对象</p>
<p>右值：不可以取地址的对象（如常量、表达式、函数返回值）</p>
<h3 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h3><p>就是对左值进行引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.左值引用只能引用左值</span></span><br><span class="line"><span class="type">int</span> t = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>&amp; rt1 = t;</span><br><span class="line"><span class="comment">//int&amp; rt2 = 8;  // 编译报错，因为8是右值，不能直接引用右值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.但是const左值引用既可以引用左值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rt3 = t;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rt4 = <span class="number">8</span>;  <span class="comment">// 也可以引用右值</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span>&amp; r1 = x + y;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span>&amp; r2 = <span class="built_in">fmin</span>(x, y);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>就是对右值进行引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.右值引用只能引用右值</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; rr1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span>&amp;&amp; rr2 = x + y;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span>&amp;&amp; rr3 = x + y;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int&amp;&amp; rrt = t;  // 编译报错，不能直接引用左值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.但是右值引用可以引用被move的左值</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; rrt = std::<span class="built_in">move</span>(t);</span><br><span class="line"><span class="type">int</span>*&amp;&amp; rr4 = std::<span class="built_in">move</span>(p);</span><br><span class="line"><span class="type">int</span>&amp;&amp; rr5 = std::<span class="built_in">move</span>(*p);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; rr6 = std::<span class="built_in">move</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//std::move移动语义：将一个对象中的资源移动到另一个对象（资源控制权的转移）</span></span><br></pre></td></tr></table></figure>

<h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>浅拷贝是创建一个新对象，新对象和原对象共享同一个底层资源，简单的赋值拷贝。浅拷贝在拷贝后对象共享同一份底层资源，可以提高效率，但是当对象<strong>析构</strong>时可能会出现不确定的行为，因为<strong>资源会被重复释放</strong>。</p>
<p>深拷贝则是创建一个新对象，，在堆中重新分配空间，新对象拥有原对象的全部资源，二者之间互不影响。深拷贝则会为每个对象创建独立的底层资源，避免了这个问题，但是会<strong>占用更多的内存</strong>。</p>
<p>当对象中有<strong>指针指向动态分配的内存</strong>时，为了安全地复制对象，需要显式地实现深拷贝，通常通过重载类的拷贝构造函数和赋值操作符来完成</p>
<h2 id="类与结构体"><a href="#类与结构体" class="headerlink" title="类与结构体"></a>类与结构体</h2><p>C语言中，结构体只是用来封装不同数据类型的数据，没有构造函数和成员函数。</p>
<p>C++中，结构体除了默认权限和继承默认权限不一样外，其他功能与类一样。（结构体默认public，类默认private）</p>
<p>在类定义中的<strong>定义</strong>的函数都是<strong>内联函数</strong>，即使没有使用 <strong>inline</strong> 说明符。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>派生类可以访问基类中所有的<strong>非私有</strong>成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p>
<p>一个派生类继承了所有的基类方法，但下列情况除外：</p>
<ul>
<li>基类的构造函数、析构函数和拷贝构造函数。</li>
<li>基类的重载运算符。</li>
<li>基类的友元函数。</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p>
<p>编译时多态、静态多态（静态链接或早绑定）：函数调用在程序执行前就准备好了。有时候这也被称为<strong>早绑定</strong>，因为 area() 函数在程序编译期间就已经设置好了，如<strong>函数重载</strong>和<strong>运算符重载</strong></p>
<p>运行时多态、动态多态（动态链接或后期绑定）：根据所调用的对象类型来选择调用的函数，如派生类中的<strong>虚函数重写</strong></p>
<h5 id="虚函数与纯虚函数"><a href="#虚函数与纯虚函数" class="headerlink" title="虚函数与纯虚函数"></a>虚函数与纯虚函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> returnType <span class="title">functionName</span><span class="params">()</span></span>&#123;</span><br><span class="line">	···</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//纯虚函数,派生类必须重写纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> returnType <span class="title">functionName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>当类中有虚函数时，会为该类生成一个虚函数指针表（虚函数表），同时为该类添加一个虚函数表指针成员（用于访问虚函数表），表中包含一个或多个函数指针，指向该类的虚函数地址</p>
<h3 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h3><p>只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。</p>
<p><strong>优势：</strong></p>
<ul>
<li>类的内部受到保护，不会因无意的用户级错误导致对象状态受损。</li>
<li>类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。</li>
</ul>
<h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><p>把数据和操作数据的函数捆绑在一起，通过将数据和操作数据的函数封装在一个类中来实现。</p>
<p><strong>访问修饰符</strong></p>
<ul>
<li><strong>private</strong>: 私有成员只能在类的内部访问，不能被类的外部代码直接访问。</li>
<li><strong>public</strong>: 公有成员可以被类的外部代码直接访问。</li>
<li><strong>protected</strong>: 受保护成员可以被类和其派生类访问。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li><strong>数据隐藏</strong>: 通过将数据成员声明为私有，防止外部代码直接访问这些数据。</li>
<li><strong>提高代码可维护性</strong>: 提供公共方法来访问和修改数据，这使得可以在不影响外部代码的情况下修改类的内部实现。</li>
<li><strong>增强安全性</strong>: 防止不合法的数据输入和不当的修改操作。</li>
<li><strong>实现抽象</strong>: 提供了一种机制，使得用户不需要了解类的内部实现细节，只需要了解如何使用类的公共接口即可。</li>
</ul>
<h3 id="接口（抽象类ABC）"><a href="#接口（抽象类ABC）" class="headerlink" title="接口（抽象类ABC）"></a>接口（抽象类ABC）</h3><p>类中<strong>至少</strong>有一个函数被声明为<strong>纯虚函数</strong>，则这个类就是抽象类。纯虚函数是通过在声明中使用 “&#x3D; 0” 来指定的。C++的接口是通过抽象类来实现的，抽象类不能被用于实例化对象，它只能作为<strong>接口</strong>使用。</p>
<p>如果一个 ABC 的子类需要被实例化，则必须实现每个纯虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。可用于实例化对象的类被称为<strong>具体类</strong>。</p>
<h3 id="构造函数类"><a href="#构造函数类" class="headerlink" title="构造函数类"></a>构造函数类</h3><p>按参数区分：有参、无参（默认构造函数）</p>
<p>按照类型区分：普通、拷贝(或复制构造)</p>
<p>拷贝构造调用情景：</p>
<p>1.对象以值的形式作为函数参数</p>
<p>2.对象以值的形式作为函数返回值</p>
<p>3.将一个对象用于给另一对象进行初始化时</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">//拷贝构造，形参必须为引用，一般会加const</span></span><br><span class="line">    <span class="comment">//一般拷贝构造函数为浅拷贝，当成员变量中存在指针变量时需定义一个深拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p)&#123;</span><br><span class="line">        <span class="meta">#statement</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://guailper.github.io">Guailper</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://guailper.github.io/2024/07/25/C++/">https://guailper.github.io/2024/07/25/C++/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://guailper.github.io" target="_blank">Guailper的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post-share"><div class="social-share" data-image="/img/cover.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav id="pagination"><div class="pagination"></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2022/07/15/2022-8-15-C/" title="C++指针"><img class="cover" src="/img/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-15</div><div class="info-item-2">C++指针</div></div><div class="info-2"><div class="info-item-1">C++指针1.悬空指针 定义：指针被释放后，还指向原来的内存空间。如： 1234void *p = malloc(size);assert(p);free(p);//此时p为悬空指针  避免方法： 1234void *p = malloc(size);assert(p);free(p);p = NULL;//赋值为NULL来避免悬空指针  2.野指针 定义：指针不确定其具体指向的内存空间。如： 12void *p;//此时p为野指针  危害：可能指向任意内存段，因此它可能会损坏正常的数据，也有可能引发其他未知错误。 避免方法： 1void *p = NULL;   </div></div></div></a><a class="pagination-related" href="/2025/03/05/C-%E9%9D%A2%E7%BB%8F/" title="C++面经"><img class="cover" src="/img/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-05</div><div class="info-item-2">C++面经</div></div><div class="info-2"><div class="info-item-1">1.头文件创建一个函数但源文件未实现该函数，会出现bug吗？  函数未被使用：编译和链接时都不报错  函数被使用：编译不报错，链接时报错（特殊情况：函数为内联函数时，编译和链接都报错）  若为模板函数（需要在头文件中声明和定义），需要在编译期进行模板实例化，会在编译期报错   2.头文件循环包含问题  当类&#x2F;结构体仅被用作指针和引用时，不用包含完整定义，用前置声明替代头文件包含，示例如下：  12345678910//A.hclass B;// 前置声明class A&#123;    B* b;// 或B &amp;b;&#125;//class A;class B&#123;    A* a;&#125;  但在源文件中需要包含具体头文件  解决重复包含问题：使用 头文件保护宏 或 #pragma once  12345//A.h#ifndef A_H#define A_H···#endif   解决依赖扩散问题：使用Pimpl解决  </div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Guailper</div><div class="author-info-description">record personal information of learn and life</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/guailper"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/guailper" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:3031975593@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/18/hello-world/" title="Hello World"><img src="/img/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2025/12/18/hello-world/" title="Hello World">Hello World</a><time datetime="2025-12-18T12:50:41.553Z" title="发表于 2025-12-18 20:50:41">2025-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/05/C-%E9%9D%A2%E7%BB%8F/" title="C++面经"><img src="/img/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++面经"/></a><div class="content"><a class="title" href="/2025/03/05/C-%E9%9D%A2%E7%BB%8F/" title="C++面经">C++面经</a><time datetime="2025-03-05T05:35:13.000Z" title="发表于 2025-03-05 13:35:13">2025-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/25/C++/" title="C++操作符重载&amp;引用"><img src="/img/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++操作符重载&amp;引用"/></a><div class="content"><a class="title" href="/2024/07/25/C++/" title="C++操作符重载&amp;引用">C++操作符重载&amp;引用</a><time datetime="2024-07-24T16:00:00.000Z" title="发表于 2024-07-25 00:00:00">2024-07-25</time></div></div></div></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/TeXt/" style="font-size: 1.45em; color: rgb(50, 152, 50);">TeXt</a><a href="/tags/Data-Structure/" style="font-size: 1.15em; color: rgb(50, 81, 168);">Data Structure</a><a href="/tags/Binary-Code/" style="font-size: 1.15em; color: rgb(50, 50, 174);">Binary_Code</a><a href="/tags/MySql/" style="font-size: 1.15em; color: rgb(116, 128, 89);">MySql</a><a href="/tags/C/" style="font-size: 1.45em; color: rgb(169, 163, 50);">C++</a><a href="/tags/Linux/" style="font-size: 1.15em; color: rgb(50, 186, 73);">Linux</a></div></div><div class="card-widget card-archives">
    <div class="item-headline">
      <i class="fas fa-archive"></i>
      <span>归档</span>
      <a class="card-more-btn" href="/archives/"
            title="查看更多">
            <i class="fas fa-angle-right"></i>
          </a>
    </div>
  
    <ul class="card-archive-list">
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/12/">
            <span class="card-archive-list-date">
              十二月 2025
            </span>
            <span class="card-archive-list-count">1</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/03/">
            <span class="card-archive-list-date">
              三月 2025
            </span>
            <span class="card-archive-list-count">1</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2024/07/">
            <span class="card-archive-list-date">
              七月 2024
            </span>
            <span class="card-archive-list-count">1</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2022/08/">
            <span class="card-archive-list-date">
              八月 2022
            </span>
            <span class="card-archive-list-count">1</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2022/07/">
            <span class="card-archive-list-date">
              七月 2022
            </span>
            <span class="card-archive-list-count">1</span>
          </a>
        </li>
      
    </ul>
  </div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Guailper</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><div class="js-pjax"></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>